package main

import "github.com/pkg/errors"

var (
	// ErrInvalidSymbol символ не из альфавита в последовательности
	ErrInvalidSymbol = errors.New("invalid symbol")
)

// Scorer оценивает разницу между символами
type Scorer interface {
	Score(a, b byte) int
}

// Adapter вспомогательная структура для работы с последовательностями некоторого алфавита
type Adapter interface {
	Scorer
	Validate(seq string) error
}

// MatrixAdapter адаптер на основе матрицы
type MatrixAdapter struct {
	inner   [][]int
	symbols map[byte]int
}

// Score оценить разницу по матрице.
// В случае, если a или b не принадлежат алфавиту паникует.
func (s *MatrixAdapter) Score(a, b byte) int {
	return s.inner[s.symbols[a]][s.symbols[b]]
}

// Validate проверяет строку на соответсвие алфавиту
func (s *MatrixAdapter) Validate(seq string) error {
	for _, a := range seq {
		if _, ok := s.symbols[byte(a)]; !ok {
			return ErrInvalidSymbol
		}
	}
	return nil
}

// NewDNAAdapter возвращает новый объект для работы с последовательностями нуклеотидов
func NewDNAAdapter() *MatrixAdapter {
	return &MatrixAdapter{
		inner: [][]int{
			{5, -4, -4, -4},
			{-4, 5, -4, -4},
			{-4, -4, 5, -4},
			{-4, -4, -4, 5},
		},
		symbols: map[byte]int{
			'A': 0,
			'T': 1,
			'G': 2,
			'C': 3,
		},
	}
}

// NewProteinAdapterBLOSUM62 возвращает новый объект для работы с последовательностями аминокислот с матрицей BLOSUM62
func NewProteinAdapterBLOSUM62() *MatrixAdapter {
	return &MatrixAdapter{
		inner: [][]int{
			{4, -1, -2, -2, 0, -1, -1, 0, -2, -1, -1, -1, -1, -2, -1, 1, 0, -3, -2, 0},
			{-1, 5, 0, -2, -3, 1, 0, -2, 0, -3, -2, 2, -1, -3, -2, -1, -1, -3, -2, -3},
			{-2, 0, 6, 1, -3, 0, 0, 0, 1, -3, -3, 0, -2, -3, -2, 1, 0, -4, -2, -3},
			{-2, -2, 1, 6, -3, 0, 2, -1, -1, -3, -4, -1, -3, -3, -1, 0, -1, -4, -3, -3},
			{0, -3, -3, -3, 9, -3, -4, -3, -3, -1, -1, -3, -1, -2, -3, -1, -1, -2, -2, -1},
			{-1, 1, 0, 0, -3, 5, 2, -2, 0, -3, -2, 1, 0, -3, -1, 0, -1, -2, -1, -2},
			{-1, 0, 0, 2, -4, 2, 5, -2, 0, -3, -3, 1, -2, -3, -1, 0, -1, -3, -2, -2},
			{0, -2, 0, -1, -3, -2, -2, 6, -2, -4, -4, -2, -3, -3, -2, 0, -2, -2, -3, -3},
			{-2, 0, 1, -1, -3, 0, 0, -2, 8, -3, -3, -1, -2, -1, -2, -1, -2, -2, 2, -3},
			{-1, -3, -3, -3, -1, -3, -3, -4, -3, 4, 2, -3, 1, 0, -3, -2, -1, -3, -1, 3},
			{-1, -2, -3, -4, -1, -2, -3, -4, -3, 2, 4, -2, 2, 0, -3, -2, -1, -2, -1, 1},
			{-1, 2, 0, -1, -3, 1, 1, -2, -1, -3, -2, 5, -1, -3, -1, 0, -1, -3, -2, -2},
			{-1, -1, -2, -3, -1, 0, -2, -3, -2, 1, 2, -1, 5, 0, -2, -1, -1, -1, -1, 1},
			{-2, -3, -3, -3, -2, -3, -3, -3, -1, 0, 0, -3, 0, 6, -4, -2, -2, 1, 3, -1},
			{-1, -2, -2, -1, -3, -1, -1, -2, -2, -3, -3, -1, -2, -4, 7, -1, -1, -4, -3, -2},
			{1, -1, 1, 0, -1, 0, 0, 0, -1, -2, -2, 0, -1, -2, -1, 4, 1, -3, -2, -2},
			{0, -1, 0, -1, -1, -1, -1, -2, -2, -1, -1, -1, -1, -2, -1, 1, 5, -2, -2, 0},
			{-3, -3, -4, -4, -2, -2, -3, -2, -2, -3, -2, -3, -1, 1, -4, -3, -2, 11, 2, -3},
			{-2, -2, -2, -3, -2, -1, -2, -3, 2, -1, -1, -2, -1, 3, -3, -2, -2, 2, 7, -1},
			{0, -3, -3, -3, -1, -2, -2, -3, -3, 3, 1, -2, 1, -1, -2, -2, 0, -3, -1, 4},
		},
		symbols: map[byte]int{
			'A': 0,
			'R': 1,
			'N': 2,
			'D': 3,
			'C': 4,
			'Q': 5,
			'E': 6,
			'G': 7,
			'H': 8,
			'I': 9,
			'L': 10,
			'K': 11,
			'M': 12,
			'F': 13,
			'P': 14,
			'S': 15,
			'T': 16,
			'W': 17,
			'Y': 18,
			'V': 19,
		},
	}
}

// NewProteinAdapterPAM250 возвращает новый объект для работы с последовательностями аминокислот с матрицей P250
func NewProteinAdapterPAM250() *MatrixAdapter {
	return &MatrixAdapter{
		inner: [][]int{
			{2, -2, 0, 0, -3, 1, -1, -1, -1, -2, -1, 0, 1, 0, -2, 1, 1, 0, -6, -3},
			{-2, 12, -5, -5, -4, -3, -3, -2, -5, -6, -5, -4, -3, -5, -4, 0, -2, -2, -8, 0},
			{0, -5, 4, 3, -6, 1, 1, -2, 0, -4, -3, 2, -1, 2, -1, 0, 0, -2, -7, -4},
			{0, -5, 3, 4, -5, 0, 1, -2, 0, -3, -2, 1, -1, 2, -1, 0, 0, -2, -7, -4},
			{-3, -4, -6, -5, 9, -5, -2, 1, -5, 2, 0, -3, -5, -5, -4, -3, -3, -1, 0, 7},
			{1, -3, 1, 0, -5, 5, -2, -3, -2, -4, -3, 0, 0, -1, -3, 1, 0, -1, -7, -5},
			{-1, -3, 1, 1, -2, -2, 6, -2, 0, -2, -2, 2, 0, 3, 2, -1, -1, -2, -3, 0},
			{-1, -2, -2, -2, 1, -3, -2, 5, -2, 2, 2, -2, -2, -2, -2, -1, 0, 4, -5, -1},
			{-1, -5, 0, 0, -5, -2, 0, -2, 5, -3, 0, 1, -1, 1, 3, 0, 0, -2, -3, -4},
			{-2, -6, -4, -3, 2, -4, -2, 2, -3, 6, 4, -3, -3, -2, -3, -3, -2, 2, -2, -1},
			{-1, -5, -3, -2, 0, -3, -2, 2, 0, 4, 6, -2, -2, -1, 0, -2, -1, 2, -4, -2},
			{0, -4, 2, 1, -3, 0, 2, -2, 1, -3, -2, 2, 0, 1, 0, 1, 0, -2, -4, -2},
			{1, -3, -1, -1, -5, 0, 0, -2, -1, -3, -2, 0, 6, 0, 0, 1, 0, -1, -6, -5},
			{0, -5, 2, 2, -5, -1, 3, -2, 1, -2, -1, 1, 0, 4, 1, -1, -1, -2, -5, -4},
			{-2, -4, -1, -1, -4, -3, 2, -2, 3, -3, 0, 0, 0, 1, 6, 0, -1, -2, 2, -4},
			{1, 0, 0, 0, -3, 1, -1, -1, 0, -3, -2, 1, 1, -1, 0, 2, 1, -1, -2, -3},
			{1, -2, 0, 0, -3, 0, -1, 0, 0, -2, -1, 0, 0, -1, -1, 1, 3, 0, -5, -3},
			{0, -2, -2, -2, -1, -1, -2, 4, -2, 2, 2, -2, -1, -2, -2, -1, 0, 4, -6, -2},
			{-6, -8, -7, -7, 0, -7, -3, -5, -3, -2, -4, -4, -6, -5, 2, -2, -5, -6, 17, 0},
			{-3, 0, -4, -4, 7, -5, 0, -1, -4, -1, -2, -2, -5, -4, -4, -3, -3, -2, 0, 10},
		},
		symbols: map[byte]int{
			'A': 0,
			'C': 1,
			'D': 2,
			'E': 3,
			'F': 4,
			'G': 5,
			'H': 6,
			'I': 7,
			'K': 8,
			'L': 9,
			'M': 10,
			'N': 11,
			'P': 12,
			'Q': 13,
			'R': 14,
			'S': 15,
			'T': 16,
			'V': 17,
			'W': 18,
			'Y': 19,
		},
	}
}

// DefaultAdapter объект по умолчанию подходит для работы с произвольными последовательностями
type DefaultAdapter struct {
}

// NewDefaultAdapter возвращает новый объект DNAScorer
func NewDefaultAdapter() *DefaultAdapter {
	return &DefaultAdapter{}
}

// Score если символы сопадают — 1, иначе — 0.
func (s *DefaultAdapter) Score(a, b byte) int {
	if a == b {
		return 1
	}
	return -1
}

// Validate любая цепочка символов без '-' (зарезервированный символ), считается валидной
func (s *DefaultAdapter) Validate(str string) error {
	for _, a := range str {
		if a == '-' {
			return ErrInvalidSymbol
		}
	}

	return nil
}

func buildAdapter(mode string) Adapter {
	switch mode {
	case dnaMode:
		return NewDNAAdapter()
	case proteinB62Mode:
		return NewProteinAdapterBLOSUM62()
	case proteinP250Mode:
		return NewProteinAdapterPAM250()
	}

	return NewDefaultAdapter()
}

func validate(a Adapter, seqs []*Sequence) error {
	for i, seq := range seqs {
		if err := a.Validate(seq.Value); err != nil {
			return errors.Wrapf(err, "sequence %d", i)
		}
	}
	return nil
}
